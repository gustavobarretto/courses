# セクション 4.2 コンピューターはどう動くか

このセクションでは、回路やスイッチ、コーディングスキーマ、バイナリ値、2^n、第5世代コンピューター、ムーアの法則、ビット、バイト、KB、MB、GB、TBとマシン語を見ていきます。

コンピューターは電気によって動きます。これは重要な事です。電気はオンとオフという2つの状態があるからです。これがため、2つの状態を_スイッチ_が_オン_なのか_オフ_なのかコーディングスキーマに当てはめるのです。

例えば、明かりのスイッチは_オン_か_オフ_ですよね。コーディングスキーマをこれと関連付けられます。お店がオープンサインを出している時、明かりは付いているものです。明かりのスイッチ(回路)がお店が開いているかどうかに使われているのです。回路やスイッチがついているかどうかをベースに、別のことを表すことができます。これはコンピューターがどう動くかについて基礎的な考え方で、何10億回とスケールアップさせていくだけです。

_回路_、_スイッチ_、_トランジスタ_という言葉はどれも互換です。回路は_オン_か_オフ_です。回路の_オン_か_オフ_の配列は何らかの意味を持ち、コーディングスキーマに関連付けられます。

1つの明かりがあれば、2つのメッセージになります(_オン_か_オフ_)。2つの明かりがあればいくつのメッセージになりますか？4つですね。1.) オン、オン 2.) オフ、オフ 3.) オン、オフ 4.) オフ、オン。3つの明かりなら？8個です。

いくつの明かりでいくつのメッセージが得られるかは、`2^n`で求めることができます。`n`が明かり(回路とかスイッチとかトランジスタとか)の数になります。そして`2^3`は`2*2*2`のことです。

```
1個の明かり = 2メッセージ
2個の明かり = 4メッセージ
3個の明かり = 8メッセージ
4個の明かり = 16メッセージ
5個の明かり = 32メッセージ
6個の明かり = 64メッセージ
7個の明かり = 128メッセージ
8個の明かり = 256メッセージ
9個の明かり = 512メッセージ
10個の明かり = 1024メッセージ
```

これらの数字は、コンピューターに関することで_何度も_見聞きしたことがあると思います。これは[2進数](https://ja.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E6%B3%95)なのです。2進数は_オン_か_オフ_かの2つの状態があります。_バイナリ_ですね。

## コーディングスキーマ
  
コーディングスキーマについて、定義をしたいと思います。以下は例です。
  
*コーディングスキーマ例*  
  
|スキーマ|結果|
|------|-------|
|on on|let's party|
|on off|movie night|
|off on|study night|
|off off|sleeping|

_オン_と_オフ_を`1`と`0`に短縮して置き換えてみましょう。`1`が_オン_を表し、`0`が_オフ_を表します。
  
`1`と`0を使ってコーディングスキーマの例をもう1度。
  
*コーディングスキーマ例*  

|スキーマ|結果|
|------|-------|
|1 1|let's party|
|1 0|movie night|
|0 1|study night|
|0 0|sleeping|  

`0`と`1`がコンピューター関連でよく使われていることがなぜかもう気づかれたでしょうか？

これこそコンピューターがどう動いているかということです。コンピューターは電気によって動きます。電気には_オン_と_オフ_という2つの状態があります。回路の状態をベースに、明かりのように、状態とメッセージを関連付けることができます。例えば、1つの明かりがある時、_オン_は"開"で_オフ_は"閉"です。こういうものを_コーディングスキーマ_と呼びます。_オン_とか_オフ_は何度も使うので、`1`を_オン_、`0`を_オフ_という短縮形で表します。

では別の例を見てきましょう。
  
|スキーマ|結果|
|-----|-------|
|0 0 0|A|
|0 0 1|B|
|0 1 0|C|
|1 0 0|D|
|1 1 0|E|
|1 0 1|F|
|0 1 1|G|
|1 1 1|H|

このコードスキーマでは、バイナリ値によってメッセージを決めています。

|スキーマ|結果|
|------|-------|
|1 1 1||
|1 1 0||
|0 0 0||
|1 0 0||
|0 0 0||
|0 1 0||
|1 1 1||
|1 1 0||

バイナリ値でメッセージを決めていると頭が痛くなってきますね。結果は次のようになります。

|スキーマ|結果|
|------|-------|
|1 1 1|H|
|1 1 0|E|
|0 0 0|A|
|1 0 0|D|
|0 0 0|A|
|0 1 0|C|
|1 1 1|H|
|1 1 0|E|  
  
## バイナリ値

バイナリ値について見ていきます。`0`と`1`はバイナリ値であると言いましたね。バイナリ値(*bi*nary digi*ts*)の短縮形がビット(_bits_)なのです。

_オン_と_オフ_、`1`と`0`、バイナリ値、ビット、そしてマシン語は、0と1だけ、もしくはスイッチの_オン_と_オフ_だけの集合で作られています。すべてバイナリ値、もしくはビットの集合です。そしてそれこそがマシン語なのです。

回路、スイッチ、トランジスタ、_ゲート_さえも、コンピュータ内部では_オン_と_オフ_だけで表されます。回路、スイッチ、ゲートは_開いている_か_閉じているか_です。これらの言葉はことはみんな同じことを言っていると気付くでしょう。_オン_と_オフ_の状態をコンピューターに保存する能力のことです。

## コーディングスキーマ

コーディングスキーマは過去によく使われていました。現在では[ASCII](https://ja.wikipedia.org/wiki/ASCII)が有名です。アルファベットが`0`と`1`に結びついています。
  
|バイナリ値|文字|
|------|-----|
|100 0001|A|
|100 0010|B|
|100 0011|C|
|100 0100|D|
|100 0101|E|
|100 0110|F|
|100 0111|G|
|100 1000|H|
|100 1001|I|
|100 1010|J|
|100 1011|K|
|100 1100|L|
|100 1101|M|
|100 1110|N|
|100 1111|O|
|101 0000|P|
|101 0001|Q|
|101 0010|R|
|101 0011|S|
|101 0100|T|
|101 0101|U|
|101 0110|V|
|101 0111|W|
|101 1000|X|
|101 1001|Y|
|101 1010|Z|

これらのスイッチ、もしくは回路の_オン_、_オフ_で表されるのが `100 0001`のとき、大文字の"A"ということになります。文字通り、大文字のAを入力した時、コンピューターのどこかの7つの回路とスイッチが_オン_、_オフ_を切り替えているのです。

最近最も有名なコーディングスキーマは[UTF-8](https://ja.wikipedia.org/wiki/UTF-8)でしょう。UTF-8のWikipediaのページにはこんなグラフがあります。

![Googleによるウェブページのエンコーディングのシェア調査](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c4/Utf8webgrowth.svg/602px-Utf8webgrowth.svg.png)

このグラフはASCIIの降下とUTF-8の上昇を示しています。ASCIIはかつてうまくいっていたものの、今は多言語をサポートしなければなりません。実は、UTF-8というもっとも有名となったコーディングスキーマを作った人達がGo言語を作りました。UTF-8の最初の部分では、ASCIIを包含しています。そう、UTF-8の最初の部分ははASCIIなのです。
  
## ビット計測

一つのバイナリ値をビットと呼びます。8ビットを1バイトと呼びます。1000バイトは1キロバイトであり、1000キロバイトは1メガバイトで、1000メガバイトは1ギガバイト、1000ギガバイトは1テラバイトです。
If you have a single binary digit, that's just called a bit. If you have 8 bits, that's called a bit. 1000 bytes is called a Kilobyte, 1000 Kilobytes is called a Megabyte, 1000 Megabytes is called a Gigabyte, and 1000 Gigabytes is called a terabyte.  
  
```
1 ビット(bit)
8 ビット(bit) = バイト(byte)
1000 バイト(byte) = キロバイト(kb)
1000 キロバイト(kb) = メガバイト(mb)
1000 メガバイト(mb) = ギガバイト(gb)
1000 ギガバイト(gb) = テラバイト(tb)
```
  
![Betty Jean JenningsとFran BilasがENIACのメインコントロールパネルを操作する様子](https://upload.wikimedia.org/wikipedia/commons/3/3b/Two_women_operating_ENIAC.gif)  

最初のコンピューターは1940年台に登場しました。最初期の電子汎用コンピューターがENIACでした。第2次世界対戦当時に、船からの弾道計算をするために作られました。気温や湿度の計測のように、早く多くの事実を考慮に入れることができる必要がありました。明かりのコーディングスキーマに沿って言うと、_オン_と_オフ_を異なる順序で整理できる16000の明かりがありました。ただ、明かりではなく、真空管を使っていました。

![現代的な真空管模型](https://upload.wikimedia.org/wikipedia/commons/e/e9/Elektronenroehren-auswahl.jpg)   

これを回路ととらえることもできます。_オン_と_オフ_があるからです。第1世代のコンピューターは真空管を_オン_と_オフ_の状態を保存するために使いました。真空管の問題は熱くなって焼け付いたり、蛾を引き寄せたりしてしまうことです。なので、コンピュータープログラミングの先駆けである[Grace Hopper](https://en.wikipedia.org/wiki/Grace_Hopper)はコンピューターから蛾を除き、これを文字通り"デバッギング(debugging 虫を取り除くの意)"と呼んでいました。

![最初のコンピューターのバグ(虫)の写真](https://upload.wikimedia.org/wikipedia/commons/8/8a/H96566k.jpg)    

第2世代コンピューターはトランジスタで動きます。焼き付きませんし、冷たいままで、とても小さくなりました。第2世代コンピューターのトランジスタは_オン_と_オフ_の状態を保存し、チェックすることができました。

![分類されたトランジスタ](https://upload.wikimedia.org/wikipedia/commons/e/e1/Transbauformen.jpg)  

第3世代のコンピューターはシリコンウェハーや_集積回路_を_オン_と_オフ_の状態の保存に使いました。

![集積回路の細部模型](https://upload.wikimedia.org/wikipedia/commons/c/c6/Siliconchip_by_shapeshifter.png)   

1971年、約2300個のトランジスタを集積回路に搭載することに成功し、1980年には[トランジスタ数](https://en.wikipedia.org/wiki/Transistor_count)は約30000を超し、1990年台には700000に、2000年台には10000000に達しました。10000000個の_オン_と_オフ_の回路です。しかもすぐにチェックすることができ、親指の爪よりも小さいのです。2011年には26億個に迫りました。

![達成できた日とトランジスタ数のプロット図](https://upload.wikimedia.org/wikipedia/commons/0/00/Transistor_Count_and_Moore%27s_Law_-_2011.svg)   

余談ですが、IntelとはIntegrated Electronicsという意味で、集積回路やチップのことです。そして、回路上のチップが2年毎に倍増するという法則のことを[ムーアの法則](https://ja.wikipedia.org/wiki/%E3%83%A0%E3%83%BC%E3%82%A2%E3%81%AE%E6%B3%95%E5%89%87)といいます。

そして、第5世代コンピューターは…

  1. 真空管
  2. トランジスタ
  3. 集積回路(チップ)
  4. マイクロプロセッサ(CPU)
  5. あなたが発見するかもしれません…

